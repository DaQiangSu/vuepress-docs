(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{368:function(t,a,e){"use strict";e.r(a);var v=e(25),r=Object(v.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"jvm运行时数据区"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jvm运行时数据区"}},[t._v("#")]),t._v(" JVM运行时数据区")]),t._v(" "),e("blockquote",[e("p",[t._v("​\tJVM分为两部分，前两者是方法区和堆内存，属于线程共享，不会被GC垃圾回收，后三者分别是虚拟机栈，本地方法区，程序计数器，属于线程独有，不共享，不会被GC垃圾回收")])]),t._v(" "),e("h2",{attrs:{id:"方法区-method-area"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#方法区-method-area"}},[t._v("#")]),t._v(" 方法区(Method Area)")]),t._v(" "),e("p",[t._v("​\t存储了每一个类的结构信息，运行时常量池，字段，方法数据，构造函数，和普通方法的字节码内容。当加载器加载.class的时候会把整个类的模板放到方法区。")]),t._v(" "),e("h2",{attrs:{id:"堆内存-heap"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#堆内存-heap"}},[t._v("#")]),t._v(" 堆内存(Heap)")]),t._v(" "),e("p",[t._v("​\t类的实例对象，方法，常变量放到对内存中，保存所有引用类型的真实信息，以方便执行器执行。")]),t._v(" "),e("h3",{attrs:{id:"新生代-yong区"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#新生代-yong区"}},[t._v("#")]),t._v(" 新生代(Yong区)")]),t._v(" "),e("p",[t._v("​\t此区占有1/3的对内存，Yong区又分为，Eden Speace(伊甸园区) ，Survivor 0 Speace(幸存者0区)，Survivor 1 Speace(幸存者1区)，此区下根据对象的特性，存活时间不长，采用的是赋值算法机制进行垃圾回收。")]),t._v(" "),e("p",[t._v("​\tEden区产生的新对象(New对象)，内存满了以后会进行一次轻GC，")]),t._v(" "),e("p",[t._v("​\tEden区GC之后剩下没有被回收的对象，复制到Survivor 0 Speace区")]),t._v(" "),e("p",[t._v("​\t下一次Eden区轻GC剩余的对象和Survivor 0 区 复制到 Survivor 1 Speace区")]),t._v(" "),e("p",[t._v("​\tSurvivor 0 Speace 和 Survivor 1 Speace区条换位置和名字，为空的为1区")]),t._v(" "),e("p",[t._v("​\t循环……")]),t._v(" "),e("p",[t._v("​\t等待对象每一次存活，年龄+1，达到15岁，移至老年代")]),t._v(" "),e("h3",{attrs:{id:"老年代-tenure-generation-speace"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#老年代-tenure-generation-speace"}},[t._v("#")]),t._v(" 老年代(Tenure Generation Speace)")]),t._v(" "),e("p",[t._v("​\t老年代内存满了以后会产生一次重GC，直至内存溢出。")]),t._v(" "),e("h2",{attrs:{id:"堆内存-heap-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#堆内存-heap-2"}},[t._v("#")]),t._v(" 堆内存(Heap)")]),t._v(" "),e("p",[t._v("​\t栈也叫栈内存，后进先出，前进后出的一个顺序，主管java程序的运行，实在线程创建时创建，他的声明周期跟随线程的生命期，线程结束，占内存也就释放，主要存放8中基本类型的变量，对象的引用变量，实例方法。每创建一个方法，都会产生一个栈针，栈针主要保存三种类型，每一个方法从条用到执行完毕的过程，都有对应着一个栈针在虚拟机中入栈出栈的过程。")]),t._v(" "),e("p",[t._v("​\t1.本地变量：输入参数和输出参数以及方法内的变量")]),t._v(" "),e("p",[t._v("​\t2.栈操作：记录出栈，入栈的操作")]),t._v(" "),e("p",[t._v("​\t3.栈针数据：类文件，方法")]),t._v(" "),e("h2",{attrs:{id:"本地方法栈-native-method-stack"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#本地方法栈-native-method-stack"}},[t._v("#")]),t._v(" 本地方法栈(Native Method Stack)")]),t._v(" "),e("p",[t._v("​\t登记Native方法，在Execution Engine执行时加载Native Libraies，也就是本地方法库，他是融合了C++的一些底层库，也称第三方库。")]),t._v(" "),e("h2",{attrs:{id:"程序计数器-pc寄存器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#程序计数器-pc寄存器"}},[t._v("#")]),t._v(" 程序计数器(PC寄存器)")]),t._v(" "),e("p",[t._v("​\t每一个线程都会有一个程序计数器，是线程私有的，线程之间不共享，也就是一个指针，指向方法区中的方法字节码，用来存储下一条指令的地址，内存区域很小，如果执行的是一个Native方法，计数器可以为空。可以完成分支，循环，跳转，异常，线程恢复等基础功能。")])])}),[],!1,null,null,null);a.default=r.exports}}]);